#include <iostream>
#include <conio.h>
#include <windows.h>
using namespace std;
const int row = 12;
const int col = 12;
struct ship
{
	int x = 1;     // Начало корабля по х. Увеличение х приводит к перемещению вправо
	int y = 1;     // Начало корабля по у. Увелечение у приводит к перемещнию вниз
	int dl = 4;    // Длина палубы
	bool horizontal = true;  // флаг горизонтальности
};
// Создание, очистка карты
void clearMap(int map[row][col], int map1[row][col]) {
	// Заполняем первую и последнюю строчку (кроме первого столбца - там будет пустота) девятками. Потом нарисуем на них буквы
	for (int i = 1; i < col - 1; i++) {
		map[0][i] = 9;
		map[11][i] = 9;
		map1[0][i] = 9;
		map1[11][i] = 9;
	}
	// Первый и последний столбец заполняем единицами. Потом там нарисуем цифры от 1 до 10.
	for (int i = 1; i < row - 1; i++) {
		map[i][0] = 1;
		map[i][11] = 1;
		map1[i][0] = 1;
		map1[i][11] = 1;
		// Остальное пространство заполним двойками. Там будет море. 
		for (int j = 1; j < col - 1; j++) {
			map[i][j] = 2;
			map1[i][j] = 2;
		}
	}
}
// Вывод двух карт на экран
void showMap(int m[row][col], int m1[row][col], const char* color = "\033[48;5;006m") {
	// Первый цикл - вывод строчек обоих полей.
	for (int i = 0; i < row; i++)
	{
		int letter = 0;  // Переменная для букв
		cout << "\n";
		// Выводим первое поле
		for (int j = 0; j < col; j++)
		{
			// От значения позиции в массиве будет зависеть цвет квадрата. И в некоторых случаях его наполнение (буквы и цифры по бокам)
			switch (m[i][j])
			{
			// 0 - граница поля. Зелёный фон
			case 0:
				cout << "\033[48;5;002m\033[38;5;15m  ";
				break;
			// 1 - граница слева и справа. Тут отображаем цифры
			case 1:
				printf("\033[48;5;002m\033[38;5;15m%-2d", i);
				break;
			// 2 -  Море. Синий цвет
			case 2:
				cout << "\033[48;5;006m  ";
				break;
			// 3 - "Несохранённый корабль", нужна только для установки кораблей в ручную. Белый цвет
			case 3:
				cout << "\033[48;5;015m  ";
				break;
			// 4 - Установленный корабль. Белый цвет
			case 4:
				cout << "\033[48;5;015m  ";
				break;
			// 5 - Вражеский прицел. Красный цвет
			case 5:
				cout << "\033[48;5;001m  ";
				break;
			// 6 - Пустое поле, после выстрела. Тёмно-синий цвет
			case 6:
				cout << "\033[48;5;027m  ";
				break;
			// 7 - Палуба корабля, в которую попали. Серый
			case 7:
				cout << "\033[48;5;245m  ";
				break;
			// 9 - Граница снизу и сверху. На зеленом фоне пишем белые буквы от А до Й. 
			case 9:
				cout << "\033[48;5;002m\033[38;5;15m" << char('А' + letter) << " ";
				letter++;
				break;
			}
		}
		// Делаем большой отступ вправо - тут будет располагаться второе поле.
		cout << "\t\t\t\t";
		letter = 0; 
		// Рисуем второе поле
		for (int j = 0; j < col; j++) {
			switch (m1[i][j])
			{
			// 0 - та же граница, только красная
			case 0:
				cout << "\033[48;5;001m\033[38;5;15m  ";
				break;
			// 1 - граница слева и справа, на красном фоне цифры от 1 до 10
			case 1:
				printf("\033[48;5;001m\033[38;5;15m%-2d", i);
				break;
			// 2 - Море, синее
			case 2:
				cout << "\033[48;5;006m  ";
				break;
			// 4 - Цвет корабля. Передаем в функцию в качестве параметра. Это нужно для автоматического боя
			case 4:
				cout << color << "  ";
				break;
			// 5 - Цвет прицела пользователя. Тёмно-тёмно синий
			case 5:
				cout << "\033[48;5;004m  ";
				break;
			// 6, 7, 9 - аналогично первому полю
			case 6:
				cout << "\033[48;5;027m  ";
				break;
			case 7:
				cout << "\033[48;5;245m  ";
				break;
			case 9:
				cout << "\033[48;5;001m\033[38;5;15m" << char('А' + letter) << " ";
				letter++;
				break;
			}
		}
	}
	cout << "\033[0m\n";
}
// Функция для заставок. Посимвольно меняет цвет строки
void changeColorAnimation(const char* startTitle, const char* color) {
	for (int j = 0; j < strlen(startTitle); j++) {
		system("cls");
		cout << "\n\t\t\t\t";
		for (int i = 0; i < strlen(startTitle); i++) {
			if (i <= j) {
				cout << color;
				cout << startTitle[i];
				cout << "\033[38;5;015m";
			}
			else {
				cout << startTitle[i];
			}
		}
		Sleep(100);
	}
}
// Проверка одной палубы корабля на соседство с другими палубами (Четвёрками).
bool checkflag(int map[row][col], int i, int j) {
	if (map[i + 1][j] == 4 ||
		map[i - 1][j] == 4 ||
		map[i][j + 1] == 4 ||
		map[i][j - 1] == 4 ||
		map[i + 1][j + 1] == 4 ||
		map[i - 1][j + 1] == 4 ||
		map[i + 1][j - 1] == 4 ||
		map[i - 1][j - 1] == 4) {
		return false;
	}
	return true;
}
// Проверка живой корабль или нет
bool checkAlive(int map[row][col], int i, int j) {
	// Проверяем соседние клетки на наличие палуб корабля, если такие есть - вернем false - корабль еще живой
	if (map[i + 1][j] == 4 ||
		map[i - 1][j] == 4 ||
		map[i][j + 1] == 4 ||
		map[i][j - 1] == 4) {
		return false;
	}
	int k = 1;
	// Нужно определить направление корабля
	// В зависимости от направления, идём по этому кораблю по раненым палубам(7), если натыкаемся на живую палубу (4), то возвращаем false - корабль еще живой
	while (map[i + k][j] == 7) {
		k++;
		if (map[i + k][j] == 4) {
			return false;
		}
	}
	while (map[i - k][j] == 7) {
		k++;
		if (map[i - k][j] == 4) {
			return false;
		}
	}
	while (map[i][j + k] == 7) {
		k++;
		if (map[i][j + k] == 4) {
			return false;
		}
	}
	while (map[i][j - k] == 7) {
		k++;
		if (map[i][j - k] == 4) {
			return false;
		}
	}
	// После того, как прошлись по всем направлениям и не нашли живой палубы, вернем true - значит корабль утонул
	return true;
}
// Обводка утонувшего кораблика
void deadShip(int map[row][col]) {
	// Проходим по всему полю (массиву) и ищем раненые корабли.
	for (int i = 1; i < row - 1; i++) {
		for (int j = 1; j < col - 1; j++) {
			// Нашли раненый корабль - делаем проверку: живой или нет. 
			// Если потоплен, каждую соседнюю клетку заменяем на квадрат, который обозначает, что в него уже был произведен выстрел (6).
			if (map[i][j] == 7 && checkAlive(map, i, j)) {
				if (map[i + 1][j] == 2) {
					map[i + 1][j] = 6;
				}
				if (map[i - 1][j] == 2) {
					map[i - 1][j] = 6;
				}
				if (map[i][j + 1] == 2) {
					map[i][j + 1] = 6;
				}
				if (map[i][j - 1] == 2) {
					map[i][j - 1] = 6;
				}
				if (map[i - 1][j + 1] == 2) {
					map[i - 1][j + 1] = 6;
				}
				if (map[i - 1][j - 1] == 2) {
					map[i - 1][j - 1] = 6;
				}
				if (map[i + 1][j + 1] == 2) {
					map[i + 1][j + 1] = 6;
				}
				if (map[i + 1][j - 1] == 2) {
					map[i + 1][j - 1] = 6;
				}
			}
		}
	}
}
// Пауза, меню выбора одного из двух
int select(int map[row][col], int map1[row][col], const char* title, const char* select1, const char* select2) {
	int key;   // Считаем сюда нажатую клавишу
	int choise = 1;   // Вернём выбор пользователя
	// Работа данной функции практически идентична функции menu(), только проще.
	do {
		const char* green = "\033[38;5;010m";
		const char* white = "\033[38;5;015m";
		system("cls");
		// Тут рисуем два, пока что пустых поля, для красоты.
		showMap(map, map1);
		cout << title;
		if (choise == 1) {
			cout << green;
			cout << select1;
			cout << white;
			cout << select2;
		}
		if (choise == 2) {
			cout << white;
			cout << select1;
			cout << green;
			cout << select2;
			cout << white;
		}
		key = _getch();
		if (key == 224) key = _getch();
		switch (key)
		{
		case 72:
			if (choise == 1) continue;
			choise--;
			break;
		case 80:
			if (choise == 2) continue;
			choise++;
			break;
		}

	} while (key != 13);
	return choise;
}
// Ручная расстановка
void manualMode(int map[row][col], int map1[row][col], ship myShips[10], int&exit) {
	int s = 0; // Считаем количество кораблей
	int key = 0; // Будем считывать номера клавишь клавиатуры
	const char* title3 = "\n\t\t\tПАУЗА: ";   // Меню паузы при нажатии Esc
	const char* selectPause1 = "\n\t\t\tПродолжить";
	const char* selectPause2 = "\n\t\t\tВыйти";
	for (int i = 0; i < 10; i++) {      // Присваем каждому караблю начальное положение в верху в углу карты
		myShips[i].x = 1;
		myShips[i].y = 1;
	}
	while (s < 10) {  // Повторям цикл пока не закончатся корабли
		bool flag = false;   // Флажок для проверки цикла
		do {
			system("cls");
			for (int i = 0; i < row; i++) {           // 3 - "несохраненные" корабли. (Активный корабль который двигают)
				for (int j = 0; j < col; j++) {       // В начале цикла убираем все несохранненые корабли
					if (map[i][j] == 3) map[i][j] = 2; // Чтобы была анимация передвижения корабля, а след за ним не тянулся
				}
			}
			for (int i = 0; i < myShips[s].dl; i++)   // Смотрим длину текущего корабля
			{                                         // 4 - "сохраненные корабли" (После установки)
				if (myShips[s].horizontal) {          // А так же его положение (горизонтальное или вертикальное)
					if (map[myShips[s].y][myShips[s].x + i] != 4) { //Проверяем не зашел ли активный корабль на сохраненный
						map[myShips[s].y][myShips[s].x + i] = 3;    // Отрисовываем корабль на доске, но не сохраняем
					}
				}
				else
					if (map[myShips[s].y + i][myShips[s].x] != 4) {  // То же самое но в вертикальном направлении
						map[myShips[s].y + i][myShips[s].x] = 3;
					}
			}
			showMap(map, map1);   // Показываем доски
			key = _getch();       // Считываем клавишу
			if (key == 224) key = _getch(); // Стрелки клавиш изначально дают 224. Считаем еще раз
			switch (key)
			{
			case 77: // Нажали вправо
				// Проверям, не упирается ли корабль в правую границу карты. Если горизонтальный, то еще и добавим длину.
				if ((myShips[s].x + myShips[s].dl == 11 && myShips[s].horizontal) || myShips[s].x >= 10) {
					continue;
				}
				// Проверка прошла - отрисовываем корабль
				myShips[s].x++;
				break;
			case 75: // Влево
				// Проверяем левую границу. Так как начальная точка корабля всегда слева, длину прибавлять не надо
				if (myShips[s].x <= 1) {
					continue;
				}
				// Всё хорошо - двигаем и отрисовываем
				myShips[s].x--;
				break;
			case 72: // Вверх
				// Аналогично с левой, только вверх
				if (myShips[s].y <= 1) {
					continue;
				}
				myShips[s].y--;
				break;
			case 80: //Вниз
				// Аналогично как мы проверяли правую границу. Только теперь проверка на нижнюю
				if ((myShips[s].y >= 10 && myShips[s].horizontal) || (myShips[s].y + myShips[s].dl == 11) && (!myShips[s].horizontal)) {
					continue;
				}
				myShips[s].y++;
				break;
			case 114: // R - поворот 
				// Если корабль был горизонатльный - станет вертикальный (уберем флажок горизонтальности)
				if (myShips[s].horizontal) {
					myShips[s].horizontal = false;
					// Проверка, чтобы при повороте корабль не задел нижнюю границу
					if (myShips[s].y + myShips[s].dl - 1 > 10) {
						// Если всё же заденет - меняем ему значание по высоте на минимально возможное.
						myShips[s].y = (10 - (myShips[s].dl - 1));
					}
				}
				else {
					// Аналогично предыдущему шагу. Ставим корабль горизонтально.
					myShips[s].horizontal = true;
					// Та же проверка и те же действия. Только проверяем теперь левую границу
					if (myShips[s].x + myShips[s].dl - 1 > 10) {
						myShips[s].x = (10 - (myShips[s].dl - 1));
					}
				}
				break;
			case 13:  // Enter
				// Переключаем флажок на тру (разрешаем поставить кораблик и перейти к следующему)
				flag = true;
				// Однако потом делаем некоторые проверки:
				// В случае если корабль расположен горизонтально
				if (myShips[s].horizontal) {
					for (int i = 0; i < myShips[s].dl; i++)   // Проходим по всей длине корабля
					{
						// По всеё длине должны быть только 3. Если находим посторонее - завершаем цикл, флагом запрещаем выходить из цикла. Функция checkflag принимает в себя координаты каждой палубы корабля, и проверяет нет ли рядом с ней 4 (сохранненого корабля). В случае если рядом четвёрок не найдено - вернет true, иначе false. Проверяем палубы слева на право
						if ((map[myShips[s].y][myShips[s].x + i] != 3) || !checkflag(map, myShips[s].y, myShips[s].x + i)) {
							flag = false;
							break;
						}
					}
				}
				// В случае вертикального корабля тоже самое, только проходимся по направлению вниз. Проверяем палубы свеху вниз
				else { 
					for (int i = 0; i < myShips[s].dl; i++)
					{
						if ((map[myShips[s].y + i][myShips[s].x] != 3) || !checkflag(map, myShips[s].y + i, myShips[s].x)) {
							flag = false;
							break;
						}
					}
				}
				break;
			case 27: // Esc
				// Выводим меню паузы, где предложим либо продолжить, либо выйти. В зависимости от выбора choise будет 1 или 2.
				int choise = select(map, map1, title3, selectPause1, selectPause2);
				if (choise == 1) { // Если "продолжить" то продолжаем расставлять
					continue;
				}
				// Если "выход", то завершаем функцию, но перед этим передаем значение по ссылке в переменную exit. Она нужна будет для проверки вне функции (чтобы игра не началась).
				else {  
					exit = 1;
					return;
				}
				break;
			}
			// Если после нажатия Enter проверка не нашла ошибок. Корабль стоит верно. А значит флаг переключаем в true и цикл завершается
		} while (flag == false);
		// Раз цикл завершился, значит все проверки прошли, а значит сохраняем корабль:
		// Ищем всё тройки и меняем их на четвёрки. Корабль сохранен.
		for (int i = 0; i < row; i++) {
			for (int j = 0; j < col; j++) {
				if (map[i][j] == 3) {
					map[i][j] = 4;
				}
			}
		}
		// Поднимаем счётчик кораблей. И идём ставить следующий корабль
		s++;
	}
}
// Автоматическая расстановка
void autoMode(int map[row][col], ship myShips[10]) {
	// Считаем корабли
	int s = 0;
	// Пока не будут поставлены все корабли
	while (s != 10) {
		// Заводим флажок, для дальнейшей проверки правильности расположения корабля
		bool flag = true;
		// Выбираем случайные координаты начала корабля
		myShips[s].y = rand() % 10 + 1;
		myShips[s].x = rand() % 10 + 1;
		// Если координаты выпали на уже стоящий корабль, или прямо рядом с ним, начинаем заного
		if ((map[myShips[s].y][myShips[s].x] == 4) || !checkflag(map, myShips[s].y, myShips[s].x)) continue;
		// Выбираем одно из четырех направлений, куда будет расти корабль.
		int dir = rand() % 4;
		// Заводим две временные переменные, будем проверять сначала на них, куда собирается вырасти корабль
		int tempX = myShips[s].x;
		int tempY = myShips[s].y;
		// Выращиваем корабль, в зависимости от его палуб и выбранного направления
		for (int i = 0; i < myShips[s].dl; i++) {
			switch (dir)
			{
			case 0:
				tempX++;
				break;
			case 1:
				tempX--;
				break;
			case 2:
				tempY++;
				break;
			case 3:
				tempY--;
				break;
			}
			// Если на каком то этапе роста корабля, видим, что корабль выходит за границы, либо упирается в другой корабль, либо подходит слишком близко к другому кораблю (ближе чем на 1 клетку), переводим флаг в false, чтобы цикл while не     пошел дальше, и завершаем цикл for (цикл роста корабля)
			if ((tempX < 1 || tempX > 10 || tempY < 1 || tempY > 10) || (map[tempY][tempX] == 4) || !checkflag(map, tempY, tempX)) {
				flag = false;
				break;
			}
		}
		// Если временные переменные все проверки прошли, то начинаем строить корабль. Теперь уже записываем по выбранным случайно и проверенным координатам, значение 4 (так обозначается корабль в массиве)
		if (flag) {
			for (int i = 0; i < myShips[s].dl; i++) {
				map[myShips[s].y][myShips[s].x] = 4;
				switch (dir)
				{
				case 0:
					myShips[s].x++;
					break;
				case 1:
					myShips[s].x--;
					break;
				case 2:
					myShips[s].y++;
					break;
				case 3:
					myShips[s].y--;
					break;
				}
			}
			system("cls");
			// Переходим к следующему кораблю
			s++;
		}
	}
}
// Ход пользователя
void usergo(int map[row][col], int map1[row][col], int& counterYou, int& crossX, int& crossY) {
	int key = 0;  // Для считывания клавиш
	int temp;     // Для того, чтобы сохранить значение массива, прежде чем по нему пройдётся прицел
	bool flag = true; // флаг для проверки правильности хода
	int alive = 0;
	// Строчки для меню паузы
	const char* title3 = "\n\t\t\tПАУЗА: ";
	const char* selectPause1 = "\n\t\t\tПродолжить";
	const char* selectPause2 = "\n\t\t\tВыйти";
	do {
		system("cls");
		flag = true;
		// Запоминаем значение массива, до того, как по нему пройдётся прицел
		temp = map1[crossY][crossX];
		// Изменяем значение массива там, где находится прицел. Ставим 5, для изменения цвета
		map1[crossY][crossX] = 5;
		// Отрисовка всех полей
		showMap(map, map1);
		cout << "\n\t\t\t\tТвой ход...";
		// После отрисовки возвращаем всё на место
		map1[crossY][crossX] = temp;
		key = _getch(); // Считываем клавишу
		if (key == 224) key = _getch();
		// В зависимости от нажатой клавиши двигаем прицел вправо, влево, вверх, вниз
		switch (key)
		{
		case 77:
			// В каждом из случаев проверяем не выходит ли прицел за границы. Если собирается выйти, то начинаем цикл заного
			if ((crossX + 1) > 10) continue;  
			crossX++;
			break;
		case 75:
			if ((crossX - 1) < 1) continue;
			crossX--;
			break;
		case 72:
			if ((crossY - 1) < 1) continue;
			crossY--;
			break;
		case 80:
			if ((crossY + 1) > 10) continue;
			crossY++;
			break;
		case 13: // Enter
			// Если пользователь хочет выстрелить туда, куда уже стрелял, ничего не делаем, возвращаемся в начало цикла
			if (map1[crossY][crossX] == 6 || map1[crossY][crossX] == 7) {
				continue;
			}
			// Разрешаем закончить ход, но делаем некоторые проверки
			flag = false;
			// Если пользователь попал по кораблю (по четвёрке), выводим соответствующее сообщение, красим раненую палубу в серый
			if (map1[crossY][crossX] == 4) {
				map1[crossY][crossX] = 7;
				cout << "\n\t\t\t\tТы ранил корабль!";
				Sleep(500);
				// Тут же делаем проверку, не потоплен ли корабль
				if (checkAlive(map1, crossY, crossX)) {
					// Если корабль утонул, обводим каждую его соседнюю клетку, чтобы было понятно - тут корабля быть не может
					deadShip(map1);
					// Повышаем счётчик потопленных вражеских кораблей
					counterYou++;
					// Если счётчик достигнет 10, выходим из цикла и заканчиваем игру
					if (counterYou == 10) break;
					cout << "\n\t\t\t\tТы потопил корабль!!";
					Sleep(500);
				}
				// Не разрешаем закончить ход, т.к после попадания по кораблю, нужно сходить еще раз
				flag = true;
			}
			// Если пользователь не попал, отмечаем пустое место, выводим сообщение и завершаем ход
			else if (map1[crossY][crossX] != 4) {
				map1[crossY][crossX] = 6;
				cout << "\n\t\t\t\tТы промазал!";
				Sleep(500);
			}
			break;
		case 27: // Если нажата Esc
			// Выводим меню паузы, где будет предложено либо выйти из игры либо продолжить
			int choise = select(map, map1, title3, selectPause1, selectPause2);
			if (choise == 1) {
				continue;
			}
			else {
				// Если выбрано выйти, заканчиваем ход, счетчик убитых кораблей делаем больше 10, чтобы игра закончилась тоже, но не выводилось сообщение о победе
				flag = false;
				counterYou = 11;
			}
			break;
		}
	} while (flag == true);
}
// Ход ИИ, случайный режим
void iirandom(int map[row][col], int map1[row][col], int& counterEnemy, int players) {
	int temp;  // Для правильного отображения прицела
	bool flag = true;  // Для проверки хода
	while (flag) {
		// Выбираем случайные координаты
		int crossX = rand() % 10 + 1;
		int crossY = rand() % 10 + 1;
		// Проверяем, чтобы координаты не были теми, куда ИИ уже стрелял
		if (map[crossY][crossX] == 6 || map[crossY][crossX] == 7) {
			continue;
		}
		temp = map[crossY][crossX];  // Для правильного отображения прицела
		map[crossY][crossX] = 5;     // Для правильного отображения прицела
		system("cls");
		// Если режим человек против ИИ, то выбираем следующую отрисовку карты и сообщений:
		if (players == 0) {
			showMap(map, map1);
			cout << "\t\t\tВраг думает, куда походить...";
			Sleep(500);
		}
		// Если бой ИИ против ИИ, выбираем следующую отрисовку:
		else {
			// Для хода каждого игрока ИИ, определенные сообщения, и определенная отрисовка карты (чтобы карта не менялась для каждого игрока)
			if (players == 1) {
				showMap(map, map1, "\033[48;5;015m");
				cout << "\t\t\tИгрок 1 думает, куда походить...";
				Sleep(500);
			}
			if (players == 2) {
				showMap(map1, map, "\033[48;5;015m");
				cout << "\t\t\tИгрок 2 думает, куда походить...";
				Sleep(500);
			}
		}
		map[crossY][crossX] = temp; // Для правильного отображения прицела
		// Если координата попала по кораблю
		if (map[crossY][crossX] == 4) {
			// Записываем его серым цветом и приравниваем к 7.
			map[crossY][crossX] = 7;
			cout << "\n\t\t\t\tВаш корабль ранен";
			Sleep(1000);
			// Если корабль еще и потоплен, отрисовываем его границы, повышаем счетчик кораблей и сразу проверяем его (на равенство 10)
			if (checkAlive(map, crossY, crossX)) {
				deadShip(map);
				counterEnemy++;
				cout << "\n\t\t\t\tВаш корабль потоплен!";
				Sleep(1000);
				if (counterEnemy == 10) break;
			}
			// Ходим еще раз
			flag = true;
		}
		// Если промазал, записываем 6 (тёмно синий), заканчиваем ход
		else if (map[crossY][crossX] == 2) {
			map[crossY][crossX] = 6;
			flag = false;
			cout << "\n\t\t\t\tМимо!";
			Sleep(1000);
		}
	}
}
// Ход ИИ, интелектуальный режим
// Отличается от случайного режима тем, что при попадании в корабль следующий выстрел не будет случайный. ИИ будет проходиться по направлениям, где может располагаться остальная часть корабля. При нахождении нужного направления, ИИ будет стрелять по нему до тех пор, пока не потопит корабль. После потопления раненного корабля, следующий выстрел производит в случайном режиме.
void ii(int map[row][col], int map1[row][col], int& counterEnemy, bool& kill,
	int& crossXkill, int& crossYkill, int& dir, int& count, int players = 0) {
	//В функцию, при помощи передачи значений по ссылке, будем запоминать координаты последнего верного выстрела, верного направления, флажок kill, который говорит есть ли на поле противника раненые корабли и счетчик раненых палуб
	int temp, crossX = 10, crossY = 10;
	int d = dir;
	bool flag = true;
	while (flag) {
		// Если раненых кораблей на поле нет - стреляем в случайную клетку
		if (!kill) {
			crossX = rand() % 10 + 1;
			crossY = rand() % 10 + 1;
		}
		// Если предыдущим выстрелом был ранен корабль:
		else {
			// Считаем палубы корабля. Действия зависят от того, сколько палуб могло остаться у корабля
			// Если корабль двухпалубный, достаточно просто пройтись по одной из четырёх соседних клеток
			// Если корабль трёх или четырёх палубный, при уничтожении следующей палубы, мы уже знаем нужное направление
			// Но если натыкаемся на пустую клетку, а корабль не уничтожен, надо будет вернуться по нужному направлению только в обратную сторону, на столько, сколько палуб уже было ранено, и снова запускать поиск направления, только в этот раз он уже потопит корабль (в случае с трёхпалубными), либо совершит еще один выстрел в обратном направлении (для четырёхпалубного)
			if (count < 2) {
				// Ищем направление (d)
				switch (d) {
				case 0:
					// Сначала всегда проверяем клетку слева
					crossX = crossXkill - 1;
					crossY = crossYkill;
					// Если там граница, или туда уже стреляли, то выстрел не совершаем а переходим сразу к другому направлению
					if (map[crossY][crossX] != 2 && map[crossY][crossX] != 4) {
						d++;
						continue;
					}
					break;
				case 1:
					crossX = crossXkill + 1;
					if (map[crossY][crossX] != 2 && map[crossY][crossX] != 4) {
						d++;
						continue;
					}
					crossY = crossYkill;
					break;
				case 2:
					crossX = crossXkill;
					crossY = crossYkill - 1;
					if (map[crossY][crossX] != 2 && map[crossY][crossX] != 4) {
						d++;
						continue;
					}
					break;
				case 3:
					crossX = crossXkill;
					crossY = crossYkill + 1;
					if (map[crossY][crossX] != 2 && map[crossY][crossX] != 4) {
						d++;
						continue;
					}
					break;
				}
			}
			else {
				// В случае если уже ранили две палубы, а корабль еще не потоплен, сначала стреляем дальше в том же направлении, что и до этого. Если там будет пусто, значит нужно будет вернуться в обратном направлении на расстояние, равное количеству раненых палуб
				switch (d) {
				case 0:
					crossX = crossXkill - 1;
					crossY = crossYkill;
					if (map[crossY][crossX] != 2 && map[crossY][crossX] != 4) {
						crossX = crossX + (count + 1);
						count = 0;
					}
					break;
				case 1:
					crossX = crossXkill + 1;
					if (map[crossY][crossX] != 2 && map[crossY][crossX] != 4) {
						crossX = crossX - (count + 1);
						count = 0;
					}
					crossY = crossYkill;
					break;
				case 2:
					crossX = crossXkill;
					crossY = crossYkill - 1;
					if (map[crossY][crossX] != 2 && map[crossY][crossX] != 4) {
						crossY = crossY + (count + 1);
						count = 0;
					}
					break;
				case 3:
					crossX = crossXkill;
					crossY = crossYkill + 1;
					if (map[crossY][crossX] != 2 && map[crossY][crossX] != 4) {
						crossY = crossY - (count + 1);
						count = 0;
					}
					break;
				}
			}
		}
		// Если случайный выстрел приведет в клетку, куда уже был произведен выстрел, возвращаем в начало цикла и ищем другие случайные координаты
		if (map[crossY][crossX] == 6 || map[crossY][crossX] == 7) {
			continue;
		}
		temp = map[crossY][crossX];  // Для отрисовки прицела
		map[crossY][crossX] = 5;     // Для отрисовки прицела
		system("cls");
		// В случае когда человек против ИИ:
		if (players == 0) {
			showMap(map, map1);
			cout << "\t\t\tВраг думает, куда походить...";
			Sleep(500);
		}
		// В случае когда ИИ против ИИ: 
		else {
			if (players == 1) {
				showMap(map, map1, "\033[48;5;015m");
				cout << "\t\t\tИгрок 1 думает, куда походить...";
				Sleep(500);
			}
			if (players == 2) {
				showMap(map1, map, "\033[48;5;015m");
				cout << "\t\t\tИгрок 2 думает, куда походить...";
				Sleep(500);
			}
		}
		map[crossY][crossX] = temp;// Для правильной отрисовки прицела
		// Если выстрел привел к клетке где находится палуба корабля:
		if (map[crossY][crossX] == 4) {
			// Отмечаем палубу серым
			map[crossY][crossX] = 7;
			// Делаем проверку, не утонул ли еще корабль
			if (checkAlive(map, crossY, crossX)) {
				// Если корабль утонул, овбводим его границы
				deadShip(map);
				// Добавляем счетчик убитых кораблей
				counterEnemy++;
				// И если это был последний корабль завершаем игру
				if (counterEnemy == 10) break;
				cout << "\n\t\t\t\tКрабль потоплен!";
				Sleep(1000);
				// Флажок переводим на false, значит, раненых кораблей больше нет
				kill = false;
				// Стираем все переменные для запоминания координат и направлений
				crossXkill = 0;
				crossYkill = 0;
				dir = 0;
				count = 0;
				d = 0;
			}
			// Если корабль еще живой
			else {
				cout << "\n\t\t\t\tКорабль ранен!";
				Sleep(1000);
				// Запоминаем выбранное направление (для случая если это уже второе попадание по кораблю, если только первое, то и направление будет равно 0)
				dir = d;
				// Запоминаем, что у врага есть раненный корабль
				kill = true;
				// Запоминаем координаты
				crossXkill = crossX;
				crossYkill = crossY;
				// Увеличиваем счетчик раненных палуб
				count++;
			}
			// Ходим еще раз
			continue;
		}
		// Если выстрел в пустую клетку, обозначаем, что клетка пустая и завершаем ход
		else if (map[crossY][crossX] == 2) {
			map[crossY][crossX] = 6;
			cout << "\n\t\t\t\tМимо!";
			Sleep(1000);
		}
		flag = false;
	}
}
// Игра против ИИ
void game(int map[row][col], int map1[row][col], int mode) {
	int counterYou = 0;  // Подсчёт потопленных вражеских кораблей
	int counterEnemy = 0; // Подсчёт потопленных врагом кораблей
	// Переменные для отслеживания прицела пользователя
	int crossX = 1, crossY = 1; 
	//Следующие переменные нужны для интелектуальной игры, они будут передаваться по ссылкам в функцию интелектуального хода, чтобы ИИ мог запоминать некоторые данные. Подробнее в самой функции ii
	int count = 0, crossXkill = 0, crossYkill = 0, dir = 0;
	bool kill = false;
	// Пока кто-нибудь из оппонентов не потопит все корабли, запускам цикл.
	while (counterYou != 10 && counterEnemy != 10) {
		// Первый ход - ход пользователя.
		// В качестве аргументов передаём по ссылке счётчик потопленных вражеских кораблей, а так же значения Х и У прицела. Чтобы не пришлось после каждого хода начинать с прицелом в начале поля, а он сохранял свои последние значения
		usergo(map, map1, counterYou, crossX, crossY);
		// После каждого хода проверяем, не потопил ли игрок все корабли.
		if (counterYou >= 10) break;
		// Если был выбран режим случайного выстрела:
		if (mode == 1) {
			// Запускаем функцию, когда ИИ стреляет по случайным клеткам. Последний параметр функции для автобоя 
			// ( 0 - бой человек против ИИ, 1, 2 - бой ИИ(1) против ИИ(2),
			iirandom(map, map1, counterEnemy, 0);
		}
		else {
			// Если выбрали интеллектуальный режим, запускам его. Количество игроков тут можно не передавать, значение по умолчанию = 0
			ii(map, map1, counterEnemy, kill, crossXkill, crossYkill, dir, count);
		}
		// Так же после каждого хода проверка, не убиты ли все корабли
		if (counterEnemy == 10) break;
		cout << "\n\t\t\t\tХод завершен";
		Sleep(500);
	}
	system("cls");
	// Рисуем окончательную карту сражений
	showMap(map, map1);
	// Проверяем кто победил
	if (counterEnemy == 10) {
		cout << "\n\t\t\t\tПоражение!\n";
		system("pause");
	}
	// Если победил пользователь, покажем ему мини-заставку с разноцветной "Победой"
	if (counterYou == 10) {
		const char* colors[4] = { "\033[38;5;005m", "\033[38;5;001m", "\033[38;5;004m", "\033[38;5;002m" };
		for (int i = 0; i < 4; i++) {
			changeColorAnimation("ПОБЕДА!", colors[i]);
		}
		showMap(map, map1);
		system("pause");
	}
	// Чистим массив
	clearMap(map, map1);
}
// Автобой
void autofight(int map[row][col], int map1[row][col], int mode) {
	// Для автобоя заводим две переменных счетчика потопленных кораблей противника
	int counterYou = 0;
	int counterEnemy = 0;
	// Как и в случае с обычным боем - заводим переменные для запоминания информации о кораблях, только теперь для каждого ИИ
	int count1 = 0, count2 = 0;
	bool kill1 = false, kill2 = false;
	int crossXkill1 = 0, crossYkill1 = 0, dir1 = 0;
	int crossXkill2 = 0, crossYkill2 = 0, dir2 = 0;
	// Цикл пока соперник ни уничтожит все корабли
	while (counterYou != 10 && counterEnemy != 10) {
		// Если выбран случайным режим:
		if (mode == 1) {
			// Последним параметром передаём номер игрока
			iirandom(map1, map, counterYou, 1);
			if (counterYou >= 10) break;
			iirandom(map, map1, counterEnemy, 2);
			if (counterYou >= 10) break;
		}
		else {
			// Если выбран ИИ режим
			ii(map1, map, counterYou, kill1, crossXkill1, crossYkill1, dir1, count1, 1);
			if (counterYou >= 10) break;
			ii(map, map1, counterEnemy, kill2, crossXkill2, crossYkill2, dir2, count2, 2);
			if (counterYou >= 10) break;
		}
		cout << "\n\t\t\t\tХод завершен";
		Sleep(500);
	}
	if (counterEnemy == 10) {
		cout << "\n\t\t\t\tИгрок 2 победил\n";
		system("pause");
	}
	if (counterYou == 10) {
		cout << "\n\t\t\t\tИгрок 1 победил\n";
		system("pause");
	}
	clearMap(map, map1);
}
// Правила
void rules() {
	system("cls");
	cout << "\n\t\t\t\t\tПРАВИЛА.\n\n";
	cout << "\t\t\t1. Расположите свои корабли на своей стороне" << endl;
	cout << "\t\t\t\tУправление: " << endl;
	cout << "\t\t\tИспользуйте стрелки влево, вверх, вправо, вниз для размещения корабля" << endl;
	cout << "\t\t\tИспользуйте Enter чтобы подтвердить расположение и R для поворота" << endl;
	cout << "\t\t\tМежду кораблями обязательно должна быть как минимум одна клетка свободного пространства" << endl;
	cout << "\t\t\tТак же доступна функция автоматической расстановки кораблей\n" << endl;
	cout << "\t\t\t2. После расстановки кораблей начнется бой" << endl;
	cout << "\t\t\tПрицельтесь на стороне противника и выстрелите, нажав Enter" << endl;
	cout << "\t\t\tПри попадании появится соответствующее сообщение, корабль противника окрасится в серый" << endl;
	cout << "\t\t\tЕсли вы попали, то можете выстрелить еще раз" << endl;
	cout << "\t\t\tПри уничтожении корабля, появится сообщение, и будут показаны границы корабля" << endl;
	cout << "\t\t\tЕсли попасть по кораблю не получилось, очередь переходит к противнику\n" << endl;
	cout << "\t\t\t3. Когда будут уничтожены все корабли у одной из сторон, игра закончится." << endl;
	cout << "\t\t\tСторона с кораблями празднует победу\n\n\n\n" << endl;
	system("pause");
}
// Автор
void author() {
	system("cls");
	cout << "\n\t\t\t\tАвтор: студент группы СБД113 - Вощакин Григорий\n\n\n\n";
	system("pause");
}
// Главное игровое меню
int menu() {
	int key;  // Переменная для считываения значений нажатых клавиш
	int choiseMain = 0;  // Значение выбора пользователя. В конце его и вернём
	do {
		system("cls");
		const char* title = "\n\t\t\t\tМОРСКОЙ БОЙ\n\n";  // Заголовок игры
		// Массив из пяти строк - содержание меню
		const char* selects[5] = { "Играть", "Автобой", "Правила","Автор","Выход" }; 
		// Две строки для подсвечивания активного выбора нужным цветом
		const char* green = "\033[38;5;010m";
		const char* white = "\033[38;5;015m";
		// Выводим заголовок
		cout << title;
		// Выводим пункты меню
		for (int i = 0; i < 5; i++) {
			if (i == choiseMain) {    // Если выбор пользователя равен пункту меню
				cout << green;        // Красим пункт в зелёный
			}
			cout << "\t\t\t\t" << selects[i] << endl; // Вывод самого пункта
			cout << white;  // Возвращаем белый цвет
		}
		key = _getch();   // Считываем клавишу (если 224, значит не правильно считали, нужно еще раз)
		if (key == 224) key = _getch();
		switch (key)
		{
		case 72:  // Клавиша вверх
			if (choiseMain == 0) continue;   // Если вверх больше некуда, то ничего и не делаем
			choiseMain--;  // Уменьшаем значение выбора (красим нижний пункт меню)
			break;
		case 80: // Клавиша вниз
			if (choiseMain == 4) continue;   // Если вниз больше некуда, то ничего и не делаем
			choiseMain++;  // Увеличиваем значение выбора (красим вверхний пункт меню)
			break;
		case 27: // Esc
			choiseMain = 4; // Если Esc то уходим
			break;
		}
		// Продолжаем цикл пока не нажата Enter или Esc
	} while (key != 13 && key != 27);  
	return choiseMain; // Возвращаем значение выбора пользователя
}
// Мини-заставка
void screen() {
	const char* startTitle = "МОРСКОЙ БОЙ";
	cout << "\n\t\t\t\t";
	for (int i = 0; i < strlen(startTitle); i++) {
		cout << startTitle[i];
		Sleep(100);
	}
	const char* colors[4] = { "\033[38;5;001m", "\033[38;5;002m", "\033[38;5;004m", "\033[38;5;005m" };
	for (int i = 0; i < 4; i++) {
		changeColorAnimation(startTitle, colors[i]);
	}
	Sleep(1000);
	system("cls");
	cout << "\n\t\t\t\t";
	cout << "\033[48;5;004m" << startTitle << "\033[0m";
	Sleep(1000);
}
int main()
{
	srand(time(0));
	setlocale(0, "");
	// Создаём два двумерных массива 12х12. Первый - наше полё. Второй - вражеское поле.
	int map[row][col]{};
	int map1[row][col]{};
	// Рисуем первоначальные поля, заполняя массивы нужными значениями.
	clearMap(map, map1);
	// Создаём массив из десяти кораблей. Структура кораблика объявлена в самом начале.
	ship myShips[10]{};
	// Заполняем его
	for (int i = 0; i < 10; i++) {
		// Первый корабль уже заполнен значениями по умолчанию (он четырёх палубный)
		if (i >= 1 && i <= 2) myShips[i].dl = 3; // Следующие два будут трёх палубные
		if (i > 2 && i < 6) myShips[i].dl = 2;   // Дальше три двухпалубных
		if (i >= 6) myShips[i].dl = 1;           // И оставшиеся четыре однопалубные
	}
	screen();
	int choiseMain; // Нам нужна будет переменная для хранения значений выбора
	do {
		// Вызываем функцию отрисовки меню. Оно вернёт значение от 0 до 4, в зависимости от выбора пользователя.
		// 0 - сама игра, 1 - автобой, 2 - правила, 3 - автор, 4 - выход
		choiseMain = menu();
		//  Разворачиваем действия, в зависимости от выбора пользователя
		switch (choiseMain) {
			// Включаем игру
		case 0: {  
			const char* selectPlacementManual = "\n\t\tРасстановка кораблей в ручную";
			const char* selectPlacementAuto = "\n\t\tАвтоматическая расстановка кораблей";
			const char* title1 = "\n\t\tВЫБОР РАССТАНОВКИ КОРАБЛЕЙ: ";
			// Переменная для проверки, не вышел ли пользователь, пока расставлял корабли.
			int exit = 0;
			// Спрашиваем пользователя, как нам расставить корабли, используя три строки выше. 
			int choise = select(map, map1, title1, selectPlacementManual, selectPlacementAuto);
			// Если пользователь захотел расставлять корабли
			if (choise == 1) {
				system("cls");
				// Запускам функцию ручной расстановки
				manualMode(map, map1, myShips, exit);
				// Если пользователь решил выйти, не расставив корабли, чистим массивы, и запускам меню по новой
				if (exit == 1) { 
					clearMap(map, map1);
					continue;
				}
			}
			// Если пользователь решил автоматически расставить корабли, запускам функцию автоматической расстановки
			else {
				autoMode(map, myShips);
			}
			// Предлагаем пользователю выбрать режим сложности ИИ
			choise = select(map, map1, "\n\t\tВЫБОР CЛОЖНОСТИ ИГРЫ: ", "\n\t\tРежим случайной стрельбы", "\n\t\tИнтеллектуальный режим");
			// Независимо от выбора, расставляем в случайном порядке корабли на втором поле.
			autoMode(map1, myShips);
			// В зависимости от выбора режима (он передается в качестве параметра choise) запускаем игру.
			game(map, map1, choise);
			break;
		}
		case 1: {
			// Если был выбран Автобой
			// Заполняем массивы кораблями автоматически
			autoMode(map, myShips);
			autoMode(map1, myShips);
			// Спрашиваем, режим сложности игры
			int choise = select(map, map1, "\n\t\tВЫБОР CЛОЖНОСТИ ИГРЫ: ", "\n\t\tРежим случайной стрельбы", "\n\t\tИнтеллектуальный режим");
			// Запускаем функцию автоматического боя
			autofight(map, map1, choise);
			break;
		}
		case 2:
			// Выводим правила
			rules();
			break;
		case 3:
			// Выводим инфо о авторе
			author();
			break;
		}
	} while (choiseMain != 4);
}